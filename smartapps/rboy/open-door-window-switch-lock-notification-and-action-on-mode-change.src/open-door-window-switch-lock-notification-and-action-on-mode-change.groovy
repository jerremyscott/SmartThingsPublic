/* **DISCLAIMER**
* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
* 1. the software will meet your requirements or expectations;
* 2. the software or the software content will be free of bugs, errors, viruses or other defects;
* 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
* 4. the software will be compatible with third party software;
* 5. any errors in the software will be corrected.
* The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
*/ 

def clientVersion() {
    return "1.5.0"
}

/**
* Notify if any doors/windows/switches are open or switches are left on when a routine changes the mode
*
* Copyright RBoy, redistribution of code is not allowed without permission
*
* 2016-9-16 - Added support to check for switches left off which should be on
* 2016-9-16 - Patch for broken HREF in ST app 2.2.0
* 2016-8-17 - Added workaround for ST contact address book bug
* 2016-7-30 - Added support for delayed actions
* 2016-7-30 - Added support for contact address books notifications
* 2016-6-6 - Fix for Android phones HREF bug
* 2016-6-3 - Fixed list of items to be checked shown on first page
* 2016-6-3 - Added support to notify if any garage doors are left open and option to close them
* 2016-6-3 - Added support to notify if any doors are left unlocked and option to lock them
* 2016-6-2 - Added support to notify if any switches are left on and option to turn them off
* 2016-6-1 - Initial release
*
*/
definition(
    name: "Open Door/Window/Switch/Lock Notification and Action on Mode Change",
    namespace: "rboy",
    author: "RBoy",
    description: "Notify if there are any doors/window/switches that are open/unlocked and closes/locks them when a mode changes. E.g. when leaving the house the mode changes to away it will notify the user if any doors are left open.",
    category: "Safety & Security",
    iconUrl: "http://smartthings.rboyapps.com/images/OpenDoor.png",
    iconX2Url: "http://smartthings.rboyapps.com/images/OpenDoor.png",
    iconX3Url: "http://smartthings.rboyapps.com/images/OpenDoor.png")

preferences {
    page(name: "mainPage")
    page(name: "modeDoorMonitorPage")
}

private getCheckingDescription(mode) {
    def description = ""

    description += settings."doors${mode}"?.join("\n  ") ?: ""
    description += settings."garagedoors${mode}"?.join("\n  ") ?: ""
    description += settings."locks${mode}"?.join("\n  ") ?: ""
    description += settings."switches${mode}"?.join("\n  ") ?: ""
    description += settings."switchesflip${mode}"?.join("\n  ") ?: ""

    if (!description) { // Nothing selected
        description = "No doors/windows selected"
    } else {
        description = "Checking:\n  " + description // Add the header
    }

    return description
}

def mainPage() {
    dynamicPage(name: "mainPage", title: "Open Door/Window/Switch Notification on Mode Change v${clientVersion()}", install: true, uninstall: true) {
        section("Mode Change Open Door/Window/Switch Notification") {
            paragraph "Click on each Mode below to configure notification options for open doors/windows/switches. When the hub changes to the selected mode and if any of the selected doors/windows are found open/unlocked, this app will notify you."
        }

        def modes = location.modes
        if (modes) {
            for (mode in modes) {
                section {
                    // Unlock actions for each mode
                    def hrefParams = [
                        mode: mode as String, 
                        passed: true 
                    ]
                    log.trace "HREF Mode $mode"
                    href(name: "modeDoorMonitor", params: hrefParams, title: "When switching to mode ${mode}", page: "modeDoorMonitorPage", description: getCheckingDescription(mode), required: false)
                }
            }
            
            section("Delay Actions and Notifications") {
                paragraph "Enable this option to allow the routines to complete their actions before checking for any open doors/windows/switches. It waits for about a minute or two before checking"
                input name: "delayAction", title: "Delay checking", type: "bool", required: false
            }
        } else {
            section("Error initializing SmartApp") {
                paragraph "No modes found on the Hub! Contact ST support"
            }
        }

        section("General Notification Options") {
            input("recipients", "contact", title: "Send notifications to (optional)", multiple: true, required: false) {
                input name: "notify", title: "Send push notifications", type: "bool", defaultValue: true, required: false
                paragraph "You can enter multiple phone numbers to send an SMS to by separating them with a '+'. E.g. 5551234567+4447654321"
                input name: "sms", title: "Send SMS notification to (optional):", type: "phone", required: false
            }
        }

        section("Change Name of App (optional)") {
            label title: "Assign a name", required: false
        }
    }
}

def modeDoorMonitorPage(params) {
    //  params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
    }

    def mode = ""
    // Get mode from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.mode) {
        mode = params.mode
        log.trace "Passed from main page, using params lookup for mode $mode"
    } else if (atomicState.params) {
        mode = atomicState.params.mode ?: ""
        log.trace "Passed from submitOnChange, atomicState lookup for mode $mode"
    } else {
        log.error "Invalid params, no mode found. Params: $params, saved params: $atomicState.params"
    }

    log.trace "Mode Door Monitor, mode:$mode, passed params: $params, saved params:$atomicState.params"

    dynamicPage(name:"modeDoorMonitorPage", title: "Configure notification options when changing to Mode " + (mode ?: ""), uninstall: false, install: false) {
        section("Choose door(s) and windows(s)") {
            paragraph "Notify if any of these selected doors or windows are open when the hub changes to $mode mode"
            input "doors${mode}", "capability.contactSensor", title: "Check these doors/windows", required: false, multiple:true
        }

        section("Choose Garage Doors(s)") {
            paragraph "Notify if any of these selected garage doors are Open when the hub changes to $mode mode"
            input "garagedoors${mode}", "capability.garageDoorControl", title: "Check these garage doors", required: false, multiple:true, submitOnChange: true
            if (settings."garagedoors${mode}") {
                input "garagedoorsoff${mode}", "bool", title: "Close them?", required: false
            }
        }

        section("Choose Locks(s)") {
            paragraph "Notify if any of these selected locks are Unlocked when the hub changes to $mode mode"
            input "locks${mode}", "capability.lock", title: "Check these locks", required: false, multiple:true, submitOnChange: true
            if (settings."locks${mode}") {
                input "locksoff${mode}", "bool", title: "Lock them?", required: false
            }
        }

        section("Choose switches(s)") {
            paragraph "Notify if any of these selected switches are On when the hub changes to $mode mode"
            input "switches${mode}", "capability.switch", title: "Check these switches left On", required: false, multiple:true, submitOnChange: true
            if (settings."switches${mode}") {
                input "switchesoff${mode}", "bool", title: "Turn them off?", required: false
            }
            paragraph "Notify if any of these selected switches are Off when the hub changes to $mode mode"
            input "switchesflip${mode}", "capability.switch", title: "Check these switches left Off", required: false, multiple:true, submitOnChange: true
            if (settings."switchesflip${mode}") {
                input "switcheson${mode}", "bool", title: "Turn them on?", required: false
            }
        }

        section("Mode Specific Notification Options") {
            paragraph "Enabling mode specific notifications will override over any general notifications defined on the first page"
            input "modeOverrideNotifications${mode}", "bool", title: "Enable $mode mode specific notifications", required: false,  submitOnChange: true
        }

        section("$mode Mode Notification Options") {
            if (settings."modeOverrideNotifications${mode}") {
                input("recipients${mode}", "contact", title: "Send notifications to (optional)", multiple: true, required: false) {
                    input name: "notify${mode}", title: "Send push notifications", type: "bool", defaultValue: true, required: false
                    paragraph "You can enter multiple phone numbers to send an SMS to by separating them with a '+'. E.g. 5551234567+4447654321"
                    input name: "sms${mode}", title: "Send SMS notification to (optional):", type: "phone", required: false
                }
            }
        }
    }
}

def installed()
{
    log.debug "Installed"

    subscribeToEvents()
}

def updated()
{
    log.debug "Updated"

    unsubscribe()
    unschedule()
    subscribeToEvents()
}

def subscribeToEvents() {
    log.trace settings

    state.queuedActions = [] // initialize it
    
    log.trace "Scheduling heartbeat for every 1 minute"
    schedule("* */1 * * * ?", heartBeat) // Schedule the heartbeat

    subscribe(location, "mode", modeChangeHandler)
}

def heartBeat() {
	log.trace "Heartbeat called, pending actions: $state.queuedActions"
    def unprocessedActions = []
    def actions = []
    
    synchronized(state) {
        if (state.queuedActions == null) { // Initialize it if it doesn't exist
            log.debug "Initializing queued Actions"
            state.queuedActions = [] // initialize it
        }

        actions = state.queuedActions.clone() // make a copy instead of working on original
        //log.warn "BEFORE CLEAR:$state.queuedActions"
        state.queuedActions.clear() // Clear it
        //log.warn "AFTER CLEAR:$state.queuedActions"
        //log.warn "EXECUTE:$actions"
    }

    for (action in actions) {
        //log.trace "Processing:$action"
        def now = now()
        if (now >= action.time) {
            log.trace "Checking state of doors/windows"
            modeChangeHandler()
        } else {
            unprocessedActions.add(action)
            log.trace "Waiting ${(((action.time - now) as Float)/1000).round()} seconds to process deferred action ${action}"
        }
    }

    if (unprocessedActions) { // If anything is pending
        log.trace "Adding unprocessed actions back to queue: $unprocessedActions"
        // Synchronize these lists otherwise we have a race condition
        synchronized(state) {
            state.queuedActions = state.queuedActions + unprocessedActions // Add back any pending actions (since we are adding an array of maps, use + and not << or .add())
            //log.warn "END:$state.queuedActions"
        }
    }
    
    log.trace "Heartbeat actions finished, pending actions: $state.queuedActions"
}

def modeChangeHandler(evt) {
    log.debug "Mode change notification, ${evt ? "name: ${evt.name}, value: ${evt.value}" : "delayed checking"}"

    // Check if we need a delayed actions
    if (evt && delayAction) {
        log.trace "Delaying checking by 1 minute"
        
        // Synchronize these lists otherwise we have a race condition
        synchronized(state) {
            if (state.queuedActions == null) { // Initialize it if it doesn't exist
                log.debug "Initializing queued Actions"
                state.queuedActions = [] // initialize it
            }

            //state.queuedActions.clear() // DEBUG CLEAR
            //log.warn "QUEUED ACTIONS: $state.queuedActions" // DEBUG

            state.queuedActions = [[time:(now() + (1 * 60 * 1000) as Long)]] // Delay checking by 1 minute (don't add map to the array only keep 1 map in the array, check for latest mode change)

            //state.queuedActions.clear() // DEBUG CLEAR
            log.trace "Queued actions: $state.queuedActions" // DEBUG
        }
        
        return
    }

    def mode = location.mode // This should the new mode

    // Check for open doors/windows
    if (settings."doors${mode}") {
        for (door in settings."doors${mode}") {
            if (door.currentValue("contact") == "open") {
                def message = "$door was Open when hub was changed to $mode mode"

                log.info message

                if (settings."modeOverrideNotifications${mode}") {
                    log.trace "Using mode specific notifications"
                    sendMessages(mode, message)
                } else {
                    log.trace "Using general notifications"
                    sendMessages(null, message)
                }
            } else {
                log.debug "$door is currently Closed"
            }
        }
    } else {
        log.trace "No doors/windows found to check when hub changed to $mode mode"
    }    

    // Check for switches left on
    if (settings."switches${mode}") {
        for (switchs in settings."switches${mode}") {
            if (switchs.currentValue("switch") == "on") {
                def message

                if (settings."switchesoff${mode}") {
                    message = "$switchs was On when hub was changed to $mode mode, turning it Off"
                    switchs.off()
                } else {
                    message = "$switchs was On when hub was changed to $mode mode"
                }

                log.info message

                if (settings."modeOverrideNotifications${mode}") {
                    log.trace "Using mode specific notifications"
                    sendMessages(mode, message)
                } else {
                    log.trace "Using general notifications"
                    sendMessages(null, message)
                }
            } else {
                log.debug "$switchs is currently Off"
            }
        }
    } else {
        log.trace "No switches found to check when hub changed to $mode mode"
    }    

    // Check for switches left off
    if (settings."switchesflip${mode}") {
        for (switchs in settings."switchesflip${mode}") {
            if (switchs.currentValue("switch") == "off") {
                def message

                if (settings."switcheson${mode}") {
                    message = "$switchs was Off when hub was changed to $mode mode, turning it On"
                    switchs.on()
                } else {
                    message = "$switchs was Off when hub was changed to $mode mode"
                }

                log.info message

                if (settings."modeOverrideNotifications${mode}") {
                    log.trace "Using mode specific notifications"
                    sendMessages(mode, message)
                } else {
                    log.trace "Using general notifications"
                    sendMessages(null, message)
                }
            } else {
                log.debug "$switchs is currently On"
            }
        }
    } else {
        log.trace "No switches found to check when hub changed to $mode mode"
    }    

    // Check for locks left unlocked
    if (settings."locks${mode}") {
        for (lock in settings."locks${mode}") {
            if (lock.currentValue("lock") == "unlocked") {
                def message

                if (settings."locksoff${mode}") {
                    message = "$lock was Unlocked when hub was changed to $mode mode, Locking it"
                    lock.lock()
                } else {
                    message = "$lock was Unlocked when hub was changed to $mode mode"
                }

                log.info message

                if (settings."modeOverrideNotifications${mode}") {
                    log.trace "Using mode specific notifications"
                    sendMessages(mode, message)
                } else {
                    log.trace "Using general notifications"
                    sendMessages(null, message)
                }
            } else {
                log.debug "$lock is currently Locked"
            }
        }
    } else {
        log.trace "No locks found to check when hub changed to $mode mode"
    }    

    // Check for garage doors left open
    if (settings."garagedoors${mode}") {
        for (garagedoor in settings."garagedoors${mode}") {
            if (garagedoor.currentValue("door") != "closed") {
                def message

                if (settings."garagedoorsoff${mode}") {
                    message = "$garagedoor was Open when hub was changed to $mode mode, Closing it"
                    lock.lock()
                } else {
                    message = "$garagedoor was Open when hub was changed to $mode mode"
                }

                log.info message

                if (settings."modeOverrideNotifications${mode}") {
                    log.trace "Using mode specific notifications"
                    sendMessages(mode, message)
                } else {
                    log.trace "Using general notifications"
                    sendMessages(null, message)
                }
            } else {
                log.debug "$garagedoor is currently Closed"
            }
        }
    } else {
        log.trace "No garage doors found to check when hub changed to $mode mode"
    }    
}

private sendText(number, message) {
    if (sms) {
        def phones = sms.split("\\+")
        for (phone in phones) {
            sendSms(phone, message)
        }
    }
}

private sendMessages(mode, message) {
    if (mode) {
        if (location.contactBookEnabled) {
            sendNotificationToContacts(message, settings."recipients${mode}")
        } else {
            if (settings."notify${mode}") {
                sendPush message
            }

            if (settings."sms${mode}") {
                sendText(settings."sms${mode}", message)
            }
        }
    } else {
        if (location.contactBookEnabled) {
            sendNotificationToContacts(message, recipients)
        } else {
            if (notify) {
                sendPush message
            }

            if (sms) {
                sendText(sms, message)
            }
        }
    }
}